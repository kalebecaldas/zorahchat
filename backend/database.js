const sqlite3 = require('sqlite3').verbose();
const { open } = require('sqlite');
const path = require('path');
const fs = require('fs');
const PostgresAdapter = require('./lib/dbAdapter');

// Detect database mode
const IS_POSTGRES = !!process.env.DATABASE_URL;

// Use /app/data in production (Railway volume for SQLite), __dirname in dev
const dataDir = process.env.NODE_ENV === 'production' ? '/app/data' : __dirname;

// Create dir if sqlite and not exists
if (!IS_POSTGRES && !fs.existsSync(dataDir)) {
    fs.mkdirSync(dataDir, { recursive: true });
}

const dbPath = path.join(dataDir, 'database.sqlite');
if (!IS_POSTGRES) {
    console.log(`[DATABASE] Using SQLite at: ${dbPath}`);
} else {
    console.log('[DATABASE] Using PostgreSQL (Detected DATABASE_URL)');
}

let db;

async function initializeDatabase() {
    if (IS_POSTGRES) {
        db = new PostgresAdapter(process.env.DATABASE_URL);
    } else {
        db = await open({
            filename: dbPath,
            driver: sqlite3.Database
        });
        await db.exec('PRAGMA foreign_keys = ON;');
    }

    // --- SCHEMA DEFINITION HELPERS ---
    // Postgres uses SERIAL or GENERATED identity, SQLite uses AUTOINCREMENT
    // Postgres uses TIMESTAMP, SQLite uses DATETIME
    const PK_TYPE = IS_POSTGRES ? 'INTEGER PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY' : 'INTEGER PRIMARY KEY AUTOINCREMENT';
    const TIMESTAMP_TYPE = IS_POSTGRES ? 'TIMESTAMP DEFAULT CURRENT_TIMESTAMP' : 'DATETIME DEFAULT CURRENT_TIMESTAMP';
    const BOOLEAN_TYPE = IS_POSTGRES ? 'BOOLEAN' : 'BOOLEAN'; // Same (Postgres has native boolean, sqlite uses 0/1 but checks work)

    // Helper to safely execute schema changes (ignore errors like "column already exists")
    const safeRun = async (sql) => {
        try {
            await db.run(sql);
        } catch (e) {
            // Check for common 'already exists' errors to ignore
            const msg = e.message.toLowerCase();
            if (!msg.includes('duplicate column') && !msg.includes('already exists')) {
                console.warn('[DB SCHEMA] Notice:', e.message);
            }
        }
    };

    console.log('[DATABASE] initializing schema...');

    // Users Table
    await db.exec(`
        CREATE TABLE IF NOT EXISTS users (
            id ${PK_TYPE},
            name TEXT NOT NULL,
            email TEXT UNIQUE NOT NULL,
            password TEXT NOT NULL,
            avatar_url TEXT,
            status TEXT DEFAULT 'online',
            status_message TEXT,
            last_seen ${TIMESTAMP_TYPE},
            created_at ${TIMESTAMP_TYPE}
        );
    `);

    // Workspaces Table
    await db.exec(`
        CREATE TABLE IF NOT EXISTS workspaces (
            id ${PK_TYPE},
            name TEXT NOT NULL,
            slug TEXT UNIQUE NOT NULL,
            description TEXT,
            avatar_url TEXT,
            owner_id INTEGER NOT NULL,
            created_at ${TIMESTAMP_TYPE},
            FOREIGN KEY (owner_id) REFERENCES users(id)
        );
    `);

    // Add columns if they don't exist (Migration logic)
    // Note: Postgres uses checking via information_schema usually, but simple ALTER ADD COLUMN IF NOT EXISTS works in newer PG
    // Since we want to support both, we wrap in try/catch block via safeRun
    // Postgres requires 'ADD COLUMN', SQLite works with just 'ADD' but prefers 'ADD COLUMN'
    await safeRun('ALTER TABLE users ADD COLUMN status TEXT DEFAULT \'online\'');
    await safeRun('ALTER TABLE users ADD COLUMN status_message TEXT');
    await safeRun('ALTER TABLE users ADD COLUMN last_seen ' + TIMESTAMP_TYPE);
    await safeRun('ALTER TABLE workspaces ADD COLUMN description TEXT');
    await safeRun('ALTER TABLE workspaces ADD COLUMN avatar_url TEXT');
    await safeRun('ALTER TABLE workspaces ADD COLUMN owner_id INTEGER');

    // Workspace Users
    await db.exec(`
        CREATE TABLE IF NOT EXISTS workspace_users (
            workspace_id INTEGER NOT NULL,
            user_id INTEGER NOT NULL,
            role TEXT DEFAULT 'member',
            permissions TEXT DEFAULT 'read,write',
            joined_at ${TIMESTAMP_TYPE},
            PRIMARY KEY (workspace_id, user_id),
            FOREIGN KEY (workspace_id) REFERENCES workspaces(id),
            FOREIGN KEY (user_id) REFERENCES users(id)
        );
    `);

    await safeRun('ALTER TABLE workspace_users ADD COLUMN permissions TEXT DEFAULT \'read,write\'');

    // Channels Table
    // type check constraint needs care in Postgres
    await db.exec(`
        CREATE TABLE IF NOT EXISTS channels (
            id ${PK_TYPE},
            workspace_id INTEGER NOT NULL,
            name TEXT NOT NULL,
            description TEXT,
            type TEXT DEFAULT 'public',
            created_by INTEGER,
            is_default ${BOOLEAN_TYPE} DEFAULT ${IS_POSTGRES ? 'false' : '0'},
            is_private ${BOOLEAN_TYPE} DEFAULT ${IS_POSTGRES ? 'false' : '0'},
            created_at ${TIMESTAMP_TYPE},
            FOREIGN KEY (workspace_id) REFERENCES workspaces(id),
            FOREIGN KEY (created_by) REFERENCES users(id)
        );
    `);

    await safeRun('ALTER TABLE channels ADD COLUMN description TEXT');
    await safeRun('ALTER TABLE channels ADD COLUMN created_by INTEGER');
    await safeRun(`ALTER TABLE channels ADD COLUMN is_default ${BOOLEAN_TYPE} DEFAULT ${IS_POSTGRES ? 'false' : '0'}`);
    await safeRun(`ALTER TABLE channels ADD COLUMN is_private ${BOOLEAN_TYPE} DEFAULT ${IS_POSTGRES ? 'false' : '0'}`);

    // Direct Messages Table
    await db.exec(`
        CREATE TABLE IF NOT EXISTS direct_messages (
            id ${PK_TYPE},
            workspace_id INTEGER NOT NULL,
            user1_id INTEGER NOT NULL,
            user2_id INTEGER NOT NULL,
            created_at ${TIMESTAMP_TYPE},
            FOREIGN KEY (workspace_id) REFERENCES workspaces(id),
            FOREIGN KEY (user1_id) REFERENCES users(id),
            FOREIGN KEY (user2_id) REFERENCES users(id),
            UNIQUE(workspace_id, user1_id, user2_id)
        );
    `);

    // Messages Table
    await db.exec(`
        CREATE TABLE IF NOT EXISTS messages (
            id ${PK_TYPE},
            channel_id INTEGER,
            dm_id INTEGER,
            user_id INTEGER NOT NULL,
            content TEXT,
            attachment_url TEXT,
            attachment_type TEXT,
            attachment_name TEXT,
            has_mentions ${BOOLEAN_TYPE} DEFAULT ${IS_POSTGRES ? 'false' : '0'},
            file_size INTEGER,
            file_dimensions TEXT,
            edited_at ${IS_POSTGRES ? 'TIMESTAMP' : 'DATETIME'},
            deleted_at ${IS_POSTGRES ? 'TIMESTAMP' : 'DATETIME'},
            created_at ${TIMESTAMP_TYPE},
            FOREIGN KEY (channel_id) REFERENCES channels(id),
            FOREIGN KEY (dm_id) REFERENCES direct_messages(id),
            FOREIGN KEY (user_id) REFERENCES users(id)
        );
    `);

    await safeRun('ALTER TABLE messages ADD COLUMN dm_id INTEGER');
    await safeRun('ALTER TABLE messages ADD COLUMN attachment_url TEXT');
    await safeRun('ALTER TABLE messages ADD COLUMN attachment_type TEXT');
    await safeRun('ALTER TABLE messages ADD COLUMN attachment_name TEXT');
    await safeRun('ALTER TABLE messages ADD COLUMN edited_at ' + (IS_POSTGRES ? 'TIMESTAMP' : 'DATETIME'));
    await safeRun('ALTER TABLE messages ADD COLUMN deleted_at ' + (IS_POSTGRES ? 'TIMESTAMP' : 'DATETIME'));
    await safeRun(`ALTER TABLE messages ADD COLUMN has_mentions ${BOOLEAN_TYPE} DEFAULT ${IS_POSTGRES ? 'false' : '0'}`);
    await safeRun('ALTER TABLE messages ADD COLUMN file_size INTEGER');
    await safeRun('ALTER TABLE messages ADD COLUMN file_dimensions TEXT');

    // Message Reactions
    await db.exec(`
        CREATE TABLE IF NOT EXISTS message_reactions (
            id ${PK_TYPE},
            message_id INTEGER NOT NULL,
            user_id INTEGER NOT NULL,
            emoji TEXT NOT NULL,
            created_at ${TIMESTAMP_TYPE},
            FOREIGN KEY (message_id) REFERENCES messages(id) ON DELETE CASCADE,
            FOREIGN KEY (user_id) REFERENCES users(id),
            UNIQUE(message_id, user_id, emoji)
        );
    `);

    // Read Receipts
    await db.exec(`
        CREATE TABLE IF NOT EXISTS read_receipts (
            id ${PK_TYPE},
            user_id INTEGER NOT NULL,
            channel_id INTEGER,
            dm_id INTEGER,
            last_read_message_id INTEGER,
            last_read_at ${TIMESTAMP_TYPE},
            FOREIGN KEY (user_id) REFERENCES users(id),
            FOREIGN KEY (channel_id) REFERENCES channels(id),
            FOREIGN KEY (dm_id) REFERENCES direct_messages(id),
            UNIQUE(user_id, channel_id, dm_id)
        );
    `);

    // Workspace Join Requests
    await db.exec(`
        CREATE TABLE IF NOT EXISTS workspace_join_requests (
            id ${PK_TYPE},
            workspace_id INTEGER NOT NULL,
            user_id INTEGER NOT NULL,
            status TEXT DEFAULT 'pending',
            created_at ${TIMESTAMP_TYPE},
            FOREIGN KEY (workspace_id) REFERENCES workspaces(id),
            FOREIGN KEY (user_id) REFERENCES users(id),
            UNIQUE(workspace_id, user_id)
        );
    `);

    // Channel Members
    await db.exec(`
        CREATE TABLE IF NOT EXISTS channel_members (
            id ${PK_TYPE},
            channel_id INTEGER NOT NULL,
            user_id INTEGER NOT NULL,
            added_by INTEGER NOT NULL,
            added_at ${TIMESTAMP_TYPE},
            FOREIGN KEY (channel_id) REFERENCES channels(id) ON DELETE CASCADE,
            FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE,
            FOREIGN KEY (added_by) REFERENCES users(id),
            UNIQUE(channel_id, user_id)
        );
    `);

    await safeRun('CREATE INDEX IF NOT EXISTS idx_channel_members_channel ON channel_members(channel_id)');
    await safeRun('CREATE INDEX IF NOT EXISTS idx_channel_members_user ON channel_members(user_id)');

    // Notifications
    // CHECK constraint syntax is standard SQL
    await db.exec(`
        CREATE TABLE IF NOT EXISTS notifications (
            id ${PK_TYPE},
            user_id INTEGER NOT NULL,
            type TEXT NOT NULL CHECK(type IN ('dm', 'mention', 'channel_invite', 'system')),
            title TEXT NOT NULL,
            content TEXT,
            link TEXT,
            read ${BOOLEAN_TYPE} DEFAULT ${IS_POSTGRES ? 'false' : '0'},
            metadata TEXT,
            created_at ${TIMESTAMP_TYPE},
            FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE
        );
    `);

    await safeRun('CREATE INDEX IF NOT EXISTS idx_notifications_user ON notifications(user_id)');
    await safeRun('CREATE INDEX IF NOT EXISTS idx_notifications_read ON notifications(user_id, read)');

    // Mentions
    await db.exec(`
        CREATE TABLE IF NOT EXISTS mentions (
            id ${PK_TYPE},
            message_id INTEGER NOT NULL,
            user_id INTEGER NOT NULL,
            created_at ${TIMESTAMP_TYPE},
            FOREIGN KEY (message_id) REFERENCES messages(id) ON DELETE CASCADE,
            FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE,
            UNIQUE(message_id, user_id)
        );
    `);

    await safeRun('CREATE INDEX IF NOT EXISTS idx_mentions_message ON mentions(message_id)');
    await safeRun('CREATE INDEX IF NOT EXISTS idx_mentions_user ON mentions(user_id)');


    console.log('Database initialized.');
    await seedDatabase();
}

async function seedDatabase() {
    const iaam = await db.get('SELECT * FROM workspaces WHERE slug = ?', ['iaam']);

    if (!iaam) {
        console.log('Seeding IAAM workspace...');
        let adminUser = await db.get('SELECT * FROM users WHERE email = ?', ['admin@iaam.com']);
        if (!adminUser) {
            const bcrypt = require('bcryptjs');
            const hashedPassword = await bcrypt.hash('admin123', 10);

            // Adapter returns object with lastID, pg adapter returns object with lastID too
            const result = await db.run(
                'INSERT INTO users (name, email, password) VALUES (?, ?, ?)',
                ['IAAM Admin', 'admin@iaam.com', hashedPassword]
            );

            // if pg, result.lastID is the id. if sqlite, result.lastID
            adminUser = { id: result.lastID };
        }

        const wsResult = await db.run(
            'INSERT INTO workspaces (name, slug, owner_id) VALUES (?, ?, ?)',
            ['IAAM', 'iaam', adminUser.id]
        );
        // workaround to get ID safely across DBs
        const workspace = await db.get('SELECT id FROM workspaces WHERE slug = ?', ['iaam']);

        await db.run(
            'INSERT INTO workspace_users (workspace_id, user_id, role, permissions) VALUES (?, ?, ?, ?)',
            [workspace.id, adminUser.id, 'admin', 'read,write,delete,manage']
        );

        // Create channels - mark general as default
        // Boolean handling
        const isDefault = IS_POSTGRES ? true : 1;
        const resultGeneral = await db.run('INSERT INTO channels (workspace_id, name, created_by, is_default) VALUES (?, ?, ?, ?)', [workspace.id, 'general', adminUser.id, isDefault]);
        await db.run('INSERT INTO channels (workspace_id, name, created_by) VALUES (?, ?, ?)', [workspace.id, 'random', adminUser.id]);

        // Add admin to general channel
        // Need ID of general channel
        let generalId = resultGeneral.lastID;
        if (!generalId && IS_POSTGRES) {
            const gChannel = await db.get('SELECT id FROM channels WHERE workspace_id = ? AND name = ?', [workspace.id, 'general']);
            generalId = gChannel.id;
        }

        await db.run('INSERT INTO channel_members (channel_id, user_id, added_by) VALUES (?, ?, ?)', [generalId, adminUser.id, adminUser.id]);
    }

    // Migrate existing workspace members to channel_members
    const existingMembers = await db.get('SELECT COUNT(*) as count FROM channel_members');
    // PG returns count as string sometimes (bigint), cast to int
    const count = parseInt(existingMembers.count || 0);

    if (count === 0) {
        console.log('Migrating existing workspace members to channels...');
        // This complex query might need adjustment for PG purely on syntax if very complex, but standard SQL usually works
        await db.exec(`
            INSERT INTO channel_members (channel_id, user_id, added_by, added_at)
            SELECT 
                c.id as channel_id,
                wu.user_id,
                wu.user_id as added_by,
                wu.joined_at as added_at
            FROM workspace_users wu
            CROSS JOIN channels c
            WHERE c.workspace_id = wu.workspace_id
            AND NOT EXISTS (
                SELECT 1 FROM channel_members cm 
                WHERE cm.channel_id = c.id AND cm.user_id = wu.user_id
            )
        `);
        console.log('Migration complete.');
    }
}

function getDb() {
    if (!db) {
        throw new Error('Database not initialized. Call initializeDatabase first.');
    }
    return db;
}

module.exports = {
    initializeDatabase,
    getDb
};
